# Log Analyzer задание

## Про логи

- Cемпл лога: nginx-access-ui.log-20170630.gz
- Шаблон названия логов интерфейса соответствует названию сэмпла (ну,только время меняется)
- Так вышло, что логи могут быть и plain и gzip лог ротируется раз в день
- Опять же, так вышло, что логи интерфейса лежат в папке с логами других сервисов

## Про отчет

- `count` - сколько раз встречается URL, абсолютное значение;
- `count_perc` - сколько раз встречается URL, в процентнах относительно общегочисла запросов;
- `time_sum` - суммарный $request_time для данного URL'а, абсолютное значение;
- `time_perc` - суммарный $request_time для данного URL'а, в процентахотносительно общего $request_time всех запросов
- `time_avg` - средний $request_time для данного URL'а
- `time_max` - максимальный $request_time для данного URL'а
- `time_med` - медиана $request_time для данного URL'а

## Основная функциональность

1. Скрипт обрабатывает при запуске последний (со самой свежей датой в имени, не по mtime файла!) лог в `LOG_DIR`, в результате работы должен получитсяотчет как в `report-2017.06.30.html` (для корректной работы нужно будетнайти и принести себе на диск `jquery.tablesorter.min.js`). То есть скриптчитает лог, парсит нужные поля, считает необходимую статистику по url'ам ирендерит шаблон report.html (в шаблоне нужно только подставить $table_json). Ситуация, что логов на обработку нет возможна, это не должно являться ошибкой;
2. Если удачно обработал, то работу не переделывает при повторном запуске.Готовые отчеты лежат в `REPORT_DIR`. В отчет попадает `REPORT_SIZE` URL'ов снаибольшим суммарным временем обработки (time_sum);
3. Скрипту должно быть возможно указать считать конфиг из другого файла,передав его путь через `--config`. У пути конфига должно быть дефолтное значение. Если файл не существует или не парсится, нужно выходить сошибкой;
4. В переменной `config` находится конфиг по умолчанию (и его не надовыносить в файл). В конфиге, считанном из файла, могут быть переопределены перменные дефолтного конфига (некоторые, все или никакие, т.е. файл может быть пустой) и они имеют более высокий приоритетпо сравнению с дефолтным конфигом. Таким образом, результирующий конфиг получается слиянием конфига из файла и дефолтного, с приоритетом конфига из файла. Ситуацию, когда конфига на диске не оказалось, нужно исключить;
5. Использовать конфиг как глобальную переменную запрещено, т.е. обращаться в своем функционале к нему так, как будто он глобальный - нельзя. Нужнопередавать как аргумент;
6. Использовать сторонние библиотеки запрещено.

## Мониторинг

1. Скрипт должен писать логи через библиотеку logging в формате
`'[%(asctime)s] %(levelname).1s %(message)s'` c датой в виде
`'%Y.%m.%d%H:%M:%S'` (`logging.basicConfig` позволит настроить это в одну строчку).Допускается только использование уровней **info**, **error** и **exception**. Путь до логфайла указывается в конфиге, если не указан, лог должен писаться в stdout (параметр filename в `logging.basicConfig` может принимать значение **None** как раз для этого).
2. Все возможные "неожиданные" ошибки должны попадать в лог вместе с трейсбеком (посмотрите на `logging.exception`). Имеются в виду ошибки не предусмотренные логикой работы, приводящие к остановке обработки и выходу: баги, нажатие ctrl+C, кончилось место на диске и т.п.
3. Должно быть предусмотрено оповещение о том, что большую часть анализируемого лога не удалось распарсить (например, потому что сменился формат логирования). Для этого нужно задаться относительным (в долях/процентах) порогом ошибок парсинга и при его превышании писать в лог, затем выходить.

## Тестирование

На скрипт должны быть написаны тесты с использованием библиотеки
unittest (<https://pymotw.com/2/unittest/>). Имя скрипта с тестами должноначинаться со слова test. Тестируемые кейсы и структура тестовопределяется самостоятельно (без фанатизма, в принципе достаточнофункциональных тестов).

## Цель задания

Получить (прокачать) навык написания production-ready кода. Тоесть адекватного кода, который удобно расширять и поддерживать,протестированного и пригодного для мониторинга. Совпадение всех чисел сприведенным примером отчета целью не является (лишь бы похожи были =)

## Критерии успеха

Задание обязательно, критерием успеха является работающийсогласно заданию код, для которого написаны тесты, проверено соответствиеpep8, написана минимальная документация с примерами запуска (боевого итестов), в README, например. Далее успешность определяется code review.
